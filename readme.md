# Extractable Keys

Read about Babylon using extractable sigs to enable slashing of btc held in timelocked utxos (self-custodial staking)
by forcing malicious parties to reveal/leak their private keys. 

While they are called extractable one time signatures, Babylon does not use actual one-time signature schemes (No Lamport or Winternitz).

Instead the idea is to force an attacker to reveal their private key by using a fixed nonce to sign (ECDSA) more than one message.
Using the same nonce `k` results in the same `r` value in a sig (ECDSA signatures are of the form `r,s`). The actual nonce `k` is 
called the "secret" nonce, while `r` is calle the "public nonce". 

In the case of Babylon, a finality provider (PoS validator) must commit in advance to a specific `r` value for each block height. Using 
any other value invalidates their vote. However, if they sign more than one block at the same height (an attack), then their private
key gets leaked. This is what this example demonstrates - and it is fairly straightforward. 

The actual usage in Babylon is a bite more complex, because they use Shnorr signs + Adaptor sigs. But the idea for private key
extraction is the same.

This repo started as just some sample code (using chatgpt) to extract private keys through nonce reuse in ecdsa.

Here's what chatgpt `4o` generated as example code (after many tries). 
The prompt was "create an example of leaking private key when reusing the nonce for ecdsa signature, use code"

The Python script `src/baseEx8.py` demonstrates how reusing a nonce in ECDSA leads to the extraction of the private key.
**Warning:** first several examples generated by chatGPT were wrong! These have been moved to `src/incorrect`

### Documentation of steps
1. Generate an ECDSA key pair (private and public key).
2. Hash two different messages.
3. Sign both messages using the same fixed nonce (k).
4. Extract the signature components (r, s) for both messages.
5. Compute the nonce (k) using the difference of message hashes and signature values.
6. Recover the private key using the extracted nonce.
7. Verify that the recovered private key matches the original.

## Mathematical Formulas Used

Nonce `k` is recovered as:

$$ k = \frac{(h_1 - h_2)}{(s_1 - s_2)} \mod n $$

Private key `d` is computed as:

```math
d = \frac{(s_1 \cdot k - h_1)}{r} \mod n
```

NOTE: Later example added for Adaptor signature

## dependencies
move into the directory and install 

```
cd extractKey
python3 -m venv .
source bin/activate
pip3 install ecdsa sympy
```

then run the example. The first few tries (baseEx-6.py) were incorrect. 

```@zsh
python3 src/baseEx.py
Original Private Key: 37893564687212102854633895298816108999726601555404879663595885242576542215566
Recovered Private Key: 109927236553837076965459908037587066718008678508067492891501834072443292643148
Keys Match: False
```

finally in the 7th attempt, chatgpt figured out the correct approach to construct the private key.

```
python3 src/baseEx8.py
Original Private Key: 17469782116885287092807181664255541698598915715172373191393715985837559617263
Recovered Private Key: 17469782116885287092807181664255541698598915715172373191393715985837559617263
Keys Match: True
```
baseEx8.py is the same, but I asked it to add documentation for the steps including the markdown for formulas used


